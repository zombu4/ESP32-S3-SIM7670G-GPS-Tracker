#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/timers.h"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_task_wdt.h"
#include "nvs_flash.h"
#include "cJSON.h"

// Include configuration and modules
#include "config.h"
#include "version.h"
#include "task_manager.h"
#include "modules/gps/gps_module.h"
#include "modules/lte/lte_module.h"
#include "modules/mqtt/mqtt_module.h"
#include "modules/battery/battery_module.h"
#include "modules/modem_init/modem_init.h"
#include "baud_rate_tester.h"

// External function declarations for MQTT JSON payload creation
extern bool mqtt_create_json_payload(const char* latitude, const char* longitude, 
                                     float battery_voltage, int battery_percentage,
                                     char* json_buffer, size_t buffer_size);
extern bool mqtt_create_enhanced_json_payload(const gps_data_t* gps_data, const battery_data_t* battery_data,
                                              bool fresh_gps_data, char* json_buffer, size_t buffer_size);

static const char *TAG = "GPS_TRACKER";

// Module interfaces
static const gps_interface_t* gps_if = NULL;
static const lte_interface_t* lte_if = NULL;
static const mqtt_interface_t* mqtt_if = NULL;
static const battery_interface_t* battery_if = NULL;

// System configuration
static tracker_system_config_t system_config = {0};

static TimerHandle_t transmission_timer;
static TimerHandle_t gps_polling_timer;
static gps_data_t last_gps_data = {0};
static battery_data_t last_battery_data = {0};
static bool fresh_gps_data_available = false;

// SAFE: Timer flags - only set from timer callbacks, read by tasks
static volatile bool gps_polling_requested = false;
static volatile bool mqtt_transmission_requested = false;

// Function prototypes
static void transmission_timer_callback(TimerHandle_t xTimer);
static void gps_polling_timer_callback(TimerHandle_t xTimer);
static bool transmit_gps_data_via_mqtt(void);
void data_aggregation_task(void* params);

// Function to get current MQTT configuration for task manager
const mqtt_config_t* gps_tracker_get_mqtt_config(void)
{
    return &system_config.mqtt;
}
static bool initialize_modules(void);
static bool collect_and_parse_gps_data(void);

void app_main(void)
{
    ESP_LOGI(TAG, "ESP32-S3-SIM7670G GPS Tracker starting...");
    
    // Display version information
    ESP_LOGI(TAG, "=== VERSION INFORMATION ===");
    ESP_LOGI(TAG, "%s", get_version_info());
    ESP_LOGI(TAG, "%s", get_build_info());
    ESP_LOGI(TAG, "===========================");
    
    // Initialize NVS with error handling
    ESP_LOGI(TAG, "üîß Initializing NVS flash storage...");
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW(TAG, "NVS flash needs to be erased, erasing...");
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize NVS flash: %s", esp_err_to_name(ret));
        return;
    }
    ESP_LOGI(TAG, "‚úÖ NVS flash initialized successfully");
    
    // Load system configuration
    if (!config_load_from_nvs(&system_config)) {
        ESP_LOGW(TAG, "Failed to load config from NVS, using defaults");
        tracker_system_config_t* defaults = config_get_default();
        memcpy(&system_config, defaults, sizeof(tracker_system_config_t));
    }
    
    // ========= WAVESHARE SIM7670G PROPER INITIALIZATION =========
    ESP_LOGI(TAG, "üîß Using Waveshare SIM7670G recommended initialization sequence");
    ESP_LOGI(TAG, "ÔøΩ Hardware: TX=17, RX=18, Baud=115200 (ESP32-S3-SIM7670G standard)");
    ESP_LOGI(TAG, "=========================================================");
    
    // CRITICAL: Initialize task manager FIRST to create UART mutex
    ESP_LOGI(TAG, "üîß Initializing task manager and UART mutex...");
    const task_manager_t* task_mgr = task_manager_get_interface();
    if (!task_mgr || !task_mgr->init()) {
        ESP_LOGE(TAG, "Failed to initialize task manager - UART mutex unavailable");
        return;
    }
    ESP_LOGI(TAG, "‚úÖ Task manager and UART mutex initialized");
    
    // Initialize all modules (now UART mutex is available)
    if (!initialize_modules()) {
        ESP_LOGE(TAG, "Failed to initialize modules");
        return;
    }
    
    // Data collection is now handled by the task manager system
    // Old standalone data collection task removed to prevent conflicts
    
    // Create synchronized timers: GPS polling (55s) + MQTT transmission (60s)
    gps_polling_timer = xTimerCreate("GPSPollingTimer", 
                                     pdMS_TO_TICKS(system_config.system.gps_polling_interval_ms),
                                     pdTRUE, 
                                     (void*)0, 
                                     gps_polling_timer_callback);
    
    transmission_timer = xTimerCreate("TransmissionTimer", 
                                      pdMS_TO_TICKS(system_config.system.transmission_interval_ms),
                                      pdTRUE, 
                                      (void*)0, 
                                      transmission_timer_callback);
                                      
    if (gps_polling_timer != NULL && transmission_timer != NULL) {
        // Start GPS polling timer immediately
        xTimerStart(gps_polling_timer, 0);
        // Start transmission timer with 5-second delay to ensure GPS data is collected first
        xTimerStart(transmission_timer, pdMS_TO_TICKS(5000));
        
        ESP_LOGI(TAG, "üì° Synchronized timers started:");
        ESP_LOGI(TAG, "  GPS polling: %d ms (55s - collect fresh data)", system_config.system.gps_polling_interval_ms);
        ESP_LOGI(TAG, "  MQTT transmission: %d ms (60s - send data)", system_config.system.transmission_interval_ms);
    } else {
        ESP_LOGE(TAG, "Failed to create synchronized timers");
    }
    
    ESP_LOGI(TAG, "GPS Tracker initialization complete");
    
    // Task watchdog is initialized by task manager - no need to initialize here
    
    // Start dual-core tasks (task manager already initialized above)
    if (task_mgr->start_all_tasks()) {
        ESP_LOGI(TAG, "‚úÖ Dual-core task system started!");
        
        // Start data aggregation task on Core 0 (with MQTT) - LARGE stack for timer processing
        xTaskCreatePinnedToCore(
            data_aggregation_task,
            "data_aggregator",
            12288,  // 12KB stack - increased for GPS/MQTT timer operations
            (void*)task_mgr,
            PRIORITY_NORMAL,
            NULL,
            PROTOCOL_CORE
        );
        ESP_LOGI(TAG, "‚úÖ Data aggregation task started on Core 0");
        
    } else {
        ESP_LOGE(TAG, "‚ùå Failed to start dual-core task system");
    }
    
    // Main supervision task - lightweight monitoring only
    // Remove unused variables - data is now handled by task manager
    uint32_t status_counter = 0;
    
    // Register main task with watchdog
    esp_err_t err = esp_task_wdt_add(NULL);
    bool watchdog_registered = (err == ESP_OK);
    if (!watchdog_registered) {
        ESP_LOGW(TAG, "Failed to add main task to watchdog: %s", esp_err_to_name(err));
        ESP_LOGI(TAG, "Main task will run without watchdog monitoring");
    }
    
    while (1) {
        // Feed watchdog only if successfully registered
        if (watchdog_registered) {
            esp_task_wdt_reset();
        }
        
        // Non-blocking status monitoring
        if (task_mgr && status_counter % 12 == 0) {  // Every minute with 5s delay
            ESP_LOGI(TAG, "üöÄ System running on dual cores - All operations non-blocking");
        }
        
        status_counter++;
        vTaskDelay(pdMS_TO_TICKS(5000));  // 5 second intervals - non-blocking
    }
}

static bool initialize_modules(void)
{
    ESP_LOGI(TAG, "üöÄ === PROPER WAVESHARE SIM7670G INITIALIZATION ===");
    
    // Get module interfaces
    gps_if = gps_get_interface();
    lte_if = lte_get_interface();
    mqtt_if = mqtt_get_interface();
    battery_if = battery_get_interface();
    
    if (!gps_if || !lte_if || !mqtt_if || !battery_if) {
        ESP_LOGE(TAG, "Failed to get module interfaces");
        return false;
    }
    
    // Initialize battery module first (independent of modem)
    ESP_LOGI(TAG, "üîã Initializing battery module...");
    if (!battery_if->init(&system_config.battery)) {
        ESP_LOGE(TAG, "Failed to initialize battery module");
        return false;
    }
    ESP_LOGI(TAG, "‚úÖ Battery module initialized");
    
    // Initialize LTE module for UART communication
    ESP_LOGI(TAG, "üì° Initializing LTE module for UART communication...");
    if (!lte_if->init(&system_config.lte)) {
        ESP_LOGE(TAG, "Failed to initialize LTE module");
        return false;
    }
    ESP_LOGI(TAG, "‚úÖ LTE module initialized");
    
    // *** CRITICAL: FOLLOW WAVESHARE SIM7670G INITIALIZATION SEQUENCE ***
    ESP_LOGI(TAG, "üìñ Following Waveshare SIM7670G recommended initialization sequence");
    
    // Execute complete modem initialization sequence
    // This includes: modem readiness, network registration, connectivity test, GPS init
    if (!modem_init_complete_sequence(120)) { // 2 minute timeout for complete sequence
        ESP_LOGE(TAG, "‚ùå Waveshare SIM7670G initialization sequence failed");
        ESP_LOGI(TAG, "‚ö° This may be normal for first GPS fix - GPS needs outdoor sky visibility");
        ESP_LOGI(TAG, "üîÑ Continuing with module initialization...");
    } else {
        ESP_LOGI(TAG, "‚úÖ Waveshare SIM7670G initialization sequence completed successfully!");
    }
    
    // Now initialize GPS module using the pre-initialized modem
    ESP_LOGI(TAG, "üõ∞Ô∏è Initializing GPS module (modem already initialized)...");
    if (!gps_if->init(&system_config.gps)) {
        ESP_LOGW(TAG, "‚ö†Ô∏è  GPS module init reported failure, but this may be expected");
        ESP_LOGI(TAG, "   üìç GPS is likely active and searching for satellites");
    } else {
        ESP_LOGI(TAG, "‚úÖ GPS module initialized");
    }
    
    // Test cellular network connectivity
    ESP_LOGI(TAG, "üåê Testing cellular network connectivity...");
    if (!lte_if->connect()) {
        ESP_LOGW(TAG, "‚ö†Ô∏è  Failed to initiate cellular network connection");
        ESP_LOGI(TAG, "   üîÑ Network may already be active from modem initialization");
    } else {
        ESP_LOGI(TAG, "‚úÖ Cellular network connection initiated");
    }
    
    // Wait for stable network connection
    ESP_LOGI(TAG, "‚è≥ Waiting for stable cellular network connection...");
    int connection_attempts = 0;
    while (lte_if->get_connection_status() != LTE_STATUS_CONNECTED && connection_attempts < 15) {
        ESP_LOGI(TAG, "   üì∂ Connection attempt %d/15...", connection_attempts + 1);
        vTaskDelay(pdMS_TO_TICKS(2000));
        connection_attempts++;
    }
    
    if (lte_if->get_connection_status() == LTE_STATUS_CONNECTED) {
        ESP_LOGI(TAG, "‚úÖ Cellular network connected successfully");
    } else {
        ESP_LOGW(TAG, "‚ö†Ô∏è  Cellular network connection not confirmed, but may be working");
        ESP_LOGI(TAG, "   üì° Network functions may work via modem initialization");
    }
    
    // Initialize MQTT module
    ESP_LOGI(TAG, "üí¨ Initializing MQTT module...");
    if (!mqtt_if->init(&system_config.mqtt)) {
        ESP_LOGE(TAG, "‚ùå Failed to initialize MQTT module");
        return false;
    }
    ESP_LOGI(TAG, "‚úÖ MQTT module initialized");
    
    ESP_LOGI(TAG, "üéâ === ALL MODULES INITIALIZED SUCCESSFULLY ===");
    return true;
}

// GPS polling timer callback - SAFE: Only sets flag, no complex operations
static void gps_polling_timer_callback(TimerHandle_t xTimer)
{
    // SAFE: Only set a flag - absolutely NO logging, function calls, or complex operations!
    gps_polling_requested = true;
}

// MQTT transmission timer callback - SAFE: Only sets flag, no complex operations  
static void transmission_timer_callback(TimerHandle_t xTimer)
{
    // SAFE: Only set a flag - absolutely NO logging, function calls, or complex operations!
    mqtt_transmission_requested = true;
}

// Note: Using mqtt_create_json_payload() instead of local implementation

/**
 * @brief Data aggregation task - collects data from queues and publishes via MQTT
 * Runs on Core 0 (Protocol Core) alongside MQTT task
 */
void data_aggregation_task(void* params)
{
    const task_manager_t* task_mgr = (const task_manager_t*)params;
    ESP_LOGI(TAG, "üìä [Core 0] Data Aggregation Task started");
    
    // Register this task with the watchdog
    esp_err_t err = esp_task_wdt_add(NULL);
    bool watchdog_registered = (err == ESP_OK);
    if (!watchdog_registered) {
        ESP_LOGW(TAG, "Failed to add data aggregation task to watchdog: %s", esp_err_to_name(err));
    }
    
    gps_data_t gps_data = {0};
    battery_data_t battery_data = {0};
    bool have_gps = false;
    bool have_battery = false;
    
    uint32_t last_publish_time = 0;
    const uint32_t publish_interval_ms = system_config.system.transmission_interval_ms;
    
    while (task_mgr->tasks_running) {
        // PRIORITY 1: Handle timer requests FIRST
        
        // Handle GPS polling timer request (SAFE: Called from task, not timer)
        if (gps_polling_requested) {
            gps_polling_requested = false; // Clear flag first
            ESP_LOGI(TAG, "üïê GPS polling timer triggered");
            if (collect_and_parse_gps_data()) {
                ESP_LOGI(TAG, "‚úÖ Fresh GPS data collected by timer");
            } else {
                ESP_LOGW(TAG, "‚ö†Ô∏è  GPS data collection failed on timer trigger");
            }
        }
        
        // Handle MQTT transmission timer request (SAFE: Called from task, not timer)
        if (mqtt_transmission_requested) {
            mqtt_transmission_requested = false; // Clear flag first
            ESP_LOGI(TAG, "üïê MQTT transmission timer triggered");
            if (transmit_gps_data_via_mqtt()) {
                ESP_LOGI(TAG, "‚úÖ MQTT transmission completed by timer");
            } else {
                ESP_LOGW(TAG, "‚ö†Ô∏è  MQTT transmission failed on timer trigger");
            }
        }
        
        // PRIORITY 2: Normal queue processing
        
        // Collect GPS data (non-blocking)
        if (xQueueReceive(task_mgr->gps_data_queue, &gps_data, pdMS_TO_TICKS(100)) == pdTRUE) {
            have_gps = true;
            ESP_LOGD(TAG, "üìç Received GPS data: %.6f,%.6f (%d sats)", 
                     gps_data.latitude, gps_data.longitude, gps_data.satellites);
        }
        
        // Collect battery data (non-blocking)
        if (xQueueReceive(task_mgr->battery_data_queue, &battery_data, pdMS_TO_TICKS(10)) == pdTRUE) {
            have_battery = true;
            ESP_LOGD(TAG, "üîã Received battery data: %.1f%% (%.2fV)", 
                     battery_data.percentage, battery_data.voltage);
        }
        
        // Publish data at regular intervals
        uint32_t current_time = esp_log_timestamp();
        if (have_gps && have_battery && 
            (current_time - last_publish_time) >= publish_interval_ms) {
            
            // Create JSON payload
            cJSON* root = cJSON_CreateObject();
            cJSON_AddNumberToObject(root, "timestamp", current_time / 1000);
            cJSON_AddStringToObject(root, "device_id", "esp32_gps_tracker");
            
            // Add GPS data
            cJSON* gps_obj = cJSON_CreateObject();
            cJSON_AddNumberToObject(gps_obj, "latitude", gps_data.latitude);
            cJSON_AddNumberToObject(gps_obj, "longitude", gps_data.longitude);
            cJSON_AddNumberToObject(gps_obj, "altitude", gps_data.altitude);
            cJSON_AddNumberToObject(gps_obj, "speed", gps_data.speed_kmh);
            cJSON_AddNumberToObject(gps_obj, "satellites", gps_data.satellites);
            cJSON_AddBoolToObject(gps_obj, "valid_fix", gps_data.fix_valid);
            cJSON_AddItemToObject(root, "gps", gps_obj);
            
            // Add battery data
            cJSON* battery_obj = cJSON_CreateObject();
            cJSON_AddNumberToObject(battery_obj, "percentage", battery_data.percentage);
            cJSON_AddNumberToObject(battery_obj, "voltage", battery_data.voltage);
            cJSON_AddBoolToObject(battery_obj, "charging", battery_data.charging);
            // Calculate low/critical battery status
            bool low_battery = battery_data.percentage < 15.0f;
            bool critical_battery = battery_data.percentage < 5.0f;
            cJSON_AddBoolToObject(battery_obj, "low_battery", low_battery);
            cJSON_AddBoolToObject(battery_obj, "critical_battery", critical_battery);
            cJSON_AddItemToObject(root, "battery", battery_obj);
            
            // Convert to string and publish
            char* json_string = cJSON_Print(root);
            if (json_string) {
                if (task_mgr->publish_mqtt(system_config.mqtt.topic, json_string, 0)) {
                    ESP_LOGI(TAG, "üì§ Data published successfully");
                    last_publish_time = current_time;
                } else {
                    ESP_LOGW(TAG, "‚ö†Ô∏è  Failed to publish data");
                }
                free(json_string);
            }
            cJSON_Delete(root);
        }
        
        // Feed watchdog and yield only if successfully registered
        if (watchdog_registered) {
            esp_task_wdt_reset();
        }
        vTaskDelay(pdMS_TO_TICKS(500));  // Check for data every 500ms
    }
    
    ESP_LOGI(TAG, "üõë [Core 0] Data Aggregation Task stopped");
    
    // Unregister from watchdog before deletion only if registered
    if (watchdog_registered) {
        esp_task_wdt_delete(NULL);
    }
    vTaskDelete(NULL);
}

// GPS data collection and parsing function
// SAFE FUNCTION: Called from tasks, NOT from timer callbacks
static bool collect_and_parse_gps_data(void)
{
    if (!gps_if) {
        ESP_LOGE(TAG, "GPS interface not available");
        return false;
    }
    
    // Read GPS data directly from the module
    gps_data_t gps_data = {0};
    if (!gps_if->read_data(&gps_data)) {
        ESP_LOGW(TAG, "Failed to read GPS data from module");
        return false;
    }
    
    // Update last known GPS data
    memcpy(&last_gps_data, &gps_data, sizeof(gps_data_t));
    
    // Also update battery data while we're at it
    if (battery_if) {
        battery_data_t battery_data = {0};
        if (battery_if->read_data(&battery_data)) {
            memcpy(&last_battery_data, &battery_data, sizeof(battery_data_t));
        }
    }
    
    ESP_LOGI(TAG, "üõ∞Ô∏è  GPS data updated: Lat=%.6f, Lon=%.6f, Alt=%.1fm, Sats=%d, HDOP=%.2f, Fix=%s", 
             gps_data.latitude, gps_data.longitude, gps_data.altitude,
             gps_data.satellites, gps_data.hdop, gps_data.fix_valid ? "VALID" : "INVALID");
    
    // Set flag that fresh data is available
    fresh_gps_data_available = true;
    
    return true;
}

// SAFE FUNCTION: Handles MQTT transmission from task context (NOT timer callback)
static bool transmit_gps_data_via_mqtt(void)
{
    ESP_LOGI(TAG, "üì° Starting MQTT data transmission...");
    
    if (!mqtt_if) {
        ESP_LOGE(TAG, "‚ùå MQTT interface not available");
        return false;
    }
    
    // Check if we have fresh GPS data
    if (!fresh_gps_data_available) {
        ESP_LOGW(TAG, "‚ö†Ô∏è  No fresh GPS data available - attempting to collect now");
        if (!collect_and_parse_gps_data()) {
            ESP_LOGW(TAG, "‚ö†Ô∏è  GPS data collection failed - using last known position");
        }
    }
    
    ESP_LOGI(TAG, "üìä GPS Data: Lat=%.6f, Lon=%.6f, Sats=%d, Fix=%s", 
             last_gps_data.latitude, last_gps_data.longitude, last_gps_data.satellites,
             last_gps_data.fix_valid ? "VALID" : "INVALID");
    
    // Check MQTT connection status
    mqtt_status_t status = mqtt_if->get_status();
    if (status != MQTT_STATUS_CONNECTED) {
        ESP_LOGW(TAG, "‚ö†Ô∏è  MQTT not connected, attempting reconnection...");
        if (!mqtt_if->connect()) {
            ESP_LOGE(TAG, "‚ùå MQTT reconnection failed");
            return false;
        }
        ESP_LOGI(TAG, "‚úÖ MQTT reconnection successful");
    }
    
    // Create enhanced JSON payload
    char json_buffer[1024];
    if (!mqtt_create_enhanced_json_payload(&last_gps_data, &last_battery_data, 
                                           fresh_gps_data_available, 
                                           json_buffer, sizeof(json_buffer))) {
        ESP_LOGE(TAG, "‚ùå Failed to create enhanced JSON payload");
        return false;
    }
    
    ESP_LOGI(TAG, "üì¶ Publishing to topic: %s", system_config.mqtt.topic);
    
    // Publish data
    mqtt_publish_result_t result = {0};
    if (mqtt_if->publish_json(system_config.mqtt.topic, json_buffer, &result)) {
        ESP_LOGI(TAG, "üéâ Data transmitted successfully to %s:%d", 
                 system_config.mqtt.broker_host, system_config.mqtt.broker_port);
        ESP_LOGI(TAG, "üìä GPS: %.6f,%.6f | Battery: %.1fV (%.0f%%) | Satellites: %d", 
                 last_gps_data.latitude, last_gps_data.longitude, last_battery_data.voltage, 
                 last_battery_data.percentage, last_gps_data.satellites);
        
        // Mark GPS data as used (for next cycle)
        fresh_gps_data_available = false;
        return true;
    } else {
        ESP_LOGW(TAG, "‚ùå Failed to transmit data via MQTT");
        return false;
    }
}